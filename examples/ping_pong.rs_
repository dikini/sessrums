//! # Ping-Pong Protocol Example
//!
//! This example demonstrates a simple ping-pong protocol implementation using session types.
//! It shows how to define protocols, create channels, and use the `send`, `recv`,
//! and `close` methods to communicate according to the protocol.
//!
//! ## Protocol Description
//!
//! The protocol implemented here is a simple ping-pong pattern:
//!
//! ```text
//! Client (Ping)                        Server (Pong)
//!   |                                     |
//!   |------- Send(Ping) ---------------->|
//!   |                                     |
//!   |<------ Recv(Pong) ----------------|
//!   |                                     |
//!   |-------------- End ---------------->|
//! ```
//!
//! This is a common pattern in client-server interactions where:
//! 1. The client sends a ping message
//! 2. The server responds with a pong message
//! 3. The communication ends

use sessrums::chan::Chan;
use sessrums::proto::{End, Protocol, Recv};
use sessrums::proto::Send as ProtoSend;
use sessrums::api::{PingClient, PingServer};
use sessrums::error::Error;
use std::thread;
use std::marker::Send;
use tokio::sync::mpsc;
use std::sync::{Arc, Mutex};
use futures_core::future::Future;
use std::pin::Pin;
use futures_core::task::{Context, Poll};

// Bidirectional channel that implements both AsyncSender and AsyncReceiver
struct BiChannel<T> {
    sender: mpsc::Sender<T>,
    receiver: Arc<Mutex<mpsc::Receiver<T>>>,
}

// Future returned by BiChannel::send
struct SendFuture<T> {
    sender: mpsc::Sender<T>,
    value: Option<T>,
}

// Future returned by BiChannel::recv
struct RecvFuture<T> {
    receiver: Arc<Mutex<mpsc::Receiver<T>>>,
    _marker: std::marker::PhantomData<T>,
}

// Implement Future for SendFuture
impl<T: std::marker::Unpin> Future for SendFuture<T> {
    type Output = Result<(), Error>;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        let this = self.get_mut();
        
        if let Some(value) = this.value.take() {
            match this.sender.try_send(value) {
                Ok(()) => Poll::Ready(Ok(())),
                Err(mpsc::error::TrySendError::Full(value)) => {
                    this.value = Some(value);
                    cx.waker().wake_by_ref();
                    Poll::Pending
                }
                Err(mpsc::error::TrySendError::Closed(_)) => {
                    Poll::Ready(Err(Error::ChannelClosed))
                }
            }
        } else {
            Poll::Ready(Err(Error::Protocol("No value to send")))
        }
    }
}

// Implement Future for RecvFuture
impl<T: std::marker::Unpin> Future for RecvFuture<T> {
    type Output = Result<T, Error>;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        let this = self.get_mut();
        
        match this.receiver.try_lock() {
            Ok(mut receiver) => {
                match receiver.try_recv() {
                    Ok(value) => Poll::Ready(Ok(value)),
                    Err(mpsc::error::TryRecvError::Empty) => {
                        cx.waker().wake_by_ref();
                        Poll::Pending
                    }
                    Err(mpsc::error::TryRecvError::Disconnected) => {
                        Poll::Ready(Err(Error::ChannelClosed))
                    }
                }
            }
            Err(_) => {
                cx.waker().wake_by_ref();
                Poll::Pending
            }
        }
    }
}

// Implement AsyncSender for BiChannel
impl<T: Clone + std::marker::Unpin> sessrums::io::AsyncSender<T> for BiChannel<T> {
    type Error = Error;
    type SendFuture<'a> = SendFuture<T> where T: 'a, Self: 'a;

    fn send(&mut self, value: T) -> Self::SendFuture<'_> {
        SendFuture {
            sender: self.sender.clone(),
            value: Some(value),
        }
    }
}

// Implement AsyncReceiver for BiChannel
impl<T: std::marker::Unpin> sessrums::io::AsyncReceiver<T> for BiChannel<T> {
    type Error = Error;
    type RecvFuture<'a> = RecvFuture<T> where T: 'a, Self: 'a;

    fn recv(&mut self) -> Self::RecvFuture<'_> {
        RecvFuture {
            receiver: self.receiver.clone(),
            _marker: std::marker::PhantomData,
        }
    }
}

/// Creates a pair of BiChannel instances for bidirectional communication
fn create_channel_pair<T>() -> (BiChannel<T>, BiChannel<T>) {
    // Create channels for client -> server and server -> client communication
    let (client_tx, server_rx) = mpsc::channel(10);
    let (server_tx, client_rx) = mpsc::channel(10);
    
    let client_channel = BiChannel {
        sender: client_tx,
        receiver: Arc::new(Mutex::new(client_rx)),
    };
    
    let server_channel = BiChannel {
        sender: server_tx,
        receiver: Arc::new(Mutex::new(server_rx)),
    };
    
    (client_channel, server_channel)
}

/// Implements the ping side of the protocol
async fn run_ping<T: Clone + std::fmt::Display + std::marker::Unpin>(chan: Chan<PingClient<T, T>, BiChannel<T>>, ping_value: T) -> Result<(), Error> {
    println!("Ping: Starting protocol");
    
    // Send a ping message
    println!("Ping: Sending message: {}", ping_value);
    let chan = chan.send(ping_value).await?;
    println!("Ping: Message sent successfully");
    
    // Receive a pong message
    println!("Ping: Waiting for response");
    let (response, chan) = chan.recv().await?;
    println!("Ping: Received response: {}", response);
    
    // Close the channel
    chan.close()?;
    println!("Ping: Protocol completed successfully");
    
    Ok(())
}

/// Implements the pong side of the protocol
async fn run_pong<T: Clone + std::fmt::Display + std::marker::Unpin>(chan: Chan<PingServer<T, T>, BiChannel<T>>, pong_value: T) -> Result<(), Error> {
    println!("Pong: Starting protocol");
    
    // Receive a ping message
    println!("Pong: Waiting for message");
    let (message, chan) = chan.recv().await?;
    println!("Pong: Received message: {}", message);
    
    // Send a pong message
    println!("Pong: Sending response: {}", pong_value);
    let chan = chan.send(pong_value).await?;
    println!("Pong: Response sent successfully");
    
    // Close the channel
    chan.close()?;
    println!("Pong: Protocol completed successfully");
    
    Ok(())
}

/// Demonstrates using the ping-pong protocol with custom values
async fn demonstrate_ping_pong<T: Clone + std::fmt::Display + Send + std::marker::Unpin + 'static>(
    ping_value: T,
    pong_value: T
) -> Result<(), Error> {
    println!("\nDemonstrating ping-pong protocol:");
    
    // Create a channel pair
    let (client_channel, server_channel) = create_channel_pair();
    
    // Create ping and pong channels with their respective protocols
    let ping_chan = Chan::<PingClient<T, T>, _>::new(client_channel);
    let pong_chan = Chan::<PingServer<T, T>, _>::new(server_channel);
    
    // Spawn the pong task in a separate thread
    let pong_value_clone = pong_value.clone();
    let pong_handle = tokio::spawn(async move {
        run_pong(pong_chan, pong_value_clone).await
    });
    
    // Run the ping task in the current thread
    run_ping(ping_chan, ping_value).await?;
    
    // Wait for the pong task to complete
    pong_handle.await.unwrap()?;
    
    println!("Ping-pong demonstration completed successfully");
    Ok(())
}

/// Demonstrates using the channel_pair function for ping-pong protocol
fn demonstrate_ping_pong_pair() {
    println!("\nDemonstrating channel_pair function for ping-pong:");
    
    // Create a pair of channels for a ping-pong protocol using the helper function
    let (client, server) = sessrums::api::channel_pair::<PingClient<i32, String>, ()>();
    
    // Verify that the channels have the correct types
    let _: Chan<PingClient<i32, String>, ()> = client;
    let _: Chan<PingServer<i32, String>, ()> = server;
    
    println!("Successfully created ping-pong channel pair with correct types");
}

/// Demonstrates the ping-pong protocol with different types
#[tokio::main]
async fn main() -> Result<(), Error> {
    println!("=== Ping-Pong Protocol Example ===\n");
    
    // Demonstrate with string values
    demonstrate_ping_pong("ping".to_string(), "pong".to_string()).await?;
    
    // Demonstrate with integer values
    demonstrate_ping_pong(42, 24).await?;
    
    // Demonstrate the ping_pong_pair helper function
    demonstrate_ping_pong_pair();
    
    println!("\n=== Example completed successfully ===");
    Ok(())
}